# Build and Push Clawdbot Umbrel Image
# =====================================
# This workflow builds a multi-arch Docker image.
#
# Build modes:
# - candidate (default): Pushes image as candidate-{version} for local testing.
#                        No CSS override, no Umbrel App Store interaction.
# - release: Pushes image as {version} + latest. Optionally triggers Umbrel update.
#
# Triggers:
# - Manual via workflow_dispatch (recommended)
# - Push to Dockerfile/patches (candidate mode only, no auto App Store update)

name: Build and Push Image

on:
  # Auto-rebuild when UI override or Dockerfile changes (candidate mode only)
  push:
    branches: [main]
    paths:
      - 'Dockerfile'
      - 'patches/**'
      - 'entrypoint.sh'
  
  # Manual trigger with full control
  workflow_dispatch:
    inputs:
      clawdbot_version:
        description: 'Version to build (e.g., v2026.1.24 or main). Leave empty for latest release.'
        required: false
        default: ''
      publish_mode:
        description: 'Build mode: candidate (for local testing) or release (for App Store)'
        required: true
        default: 'candidate'
        type: choice
        options:
          - candidate
          - release
      force_build:
        description: 'Force build even if image tag already exists'
        required: false
        default: false
        type: boolean
      umbrel_ui_override:
        description: 'Apply Umbrel UI override CSS (usually not needed for testing)'
        required: false
        default: false
        type: boolean
      update_umbrel_store:
        description: 'Trigger Umbrel App Store PR update (release mode only)'
        required: false
        default: false
        type: boolean
      run_ui_tests:
        description: 'Run UI regression tests after build'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository_owner }}/clawdbot-umbrel

# Workflow-level permissions
# - contents: write is required for repository_dispatch to trigger update workflow
# - packages: write is required for GHCR package publishing
permissions:
  contents: write
  packages: write

jobs:
  check-version:
    runs-on: ubuntu-latest
    outputs:
      should_build: ${{ steps.check.outputs.should_build }}
      version: ${{ steps.check.outputs.version }}
      publish_mode: ${{ steps.mode.outputs.publish_mode }}
      has_upstream_fix: ${{ steps.check_ui_fix.outputs.has_upstream_fix }}
    steps:
      - name: Determine publish mode
        id: mode
        run: |
          # Push events always use candidate mode (safe default)
          if [[ "${{ github.event_name }}" == "push" ]]; then
            echo "Push event detected - using candidate mode (no App Store interaction)"
            echo "publish_mode=candidate" >> $GITHUB_OUTPUT
          else
            MODE="${{ github.event.inputs.publish_mode }}"
            echo "Manual trigger - using ${MODE:-candidate} mode"
            echo "publish_mode=${MODE:-candidate}" >> $GITHUB_OUTPUT
          fi
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Get latest OpenClaw release
        id: upstream
        env:
          EVENT_NAME: ${{ github.event_name }}
        run: |
          # Get latest release from OpenClaw repo (canonical upstream) with proper error handling
          echo "Fetching latest release from OpenClaw repository..."
          
          HTTP_RESPONSE=$(curl -s -w "\n%{http_code}" https://api.github.com/repos/openclaw/openclaw/releases/latest)
          HTTP_CODE=$(echo "$HTTP_RESPONSE" | tail -n1)
          RESPONSE_BODY=$(echo "$HTTP_RESPONSE" | sed '$d')
          
          if [[ "$HTTP_CODE" != "200" ]]; then
            echo "::warning::GitHub API returned HTTP $HTTP_CODE"
            echo "Response: $RESPONSE_BODY"
            # For push events, we need a proper version - fail instead of using main
            if [[ "$EVENT_NAME" == "push" ]]; then
              echo "::error::Cannot determine upstream version for auto-rebuild. Skipping build."
              echo "latest_version=" >> $GITHUB_OUTPUT
              exit 0
            fi
            echo "Falling back to 'main' branch for manual trigger."
            echo "latest_version=main" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          LATEST=$(echo "$RESPONSE_BODY" | jq -r '.tag_name // empty')
          
          # Validate tag format (must be non-empty and start with 'v' for releases)
          if [[ -z "$LATEST" ]]; then
            echo "::warning::No tag_name found in release response."
            if [[ "$EVENT_NAME" == "push" ]]; then
              echo "::error::Cannot determine upstream version for auto-rebuild. Skipping build."
              echo "latest_version=" >> $GITHUB_OUTPUT
              exit 0
            fi
            echo "Falling back to 'main' branch for manual trigger."
            echo "latest_version=main" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Validate version tag format (e.g., v2026.1.24 or v1.0.0)
          if [[ ! "$LATEST" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ && "$LATEST" != "main" ]]; then
            echo "::warning::Unexpected version format: '$LATEST'. Proceeding anyway."
          fi
          
          echo "latest_version=${LATEST}" >> $GITHUB_OUTPUT
          echo "âœ… Latest upstream version: ${LATEST}"

      - name: Check if upstream includes UI scroll fix
        id: check_ui_fix
        env:
          LATEST_VERSION: ${{ steps.upstream.outputs.latest_version }}
          INPUT_VERSION: ${{ github.event.inputs.clawdbot_version }}
        run: |
          # Determine which version to check
          VERSION="${INPUT_VERSION:-$LATEST_VERSION}"
          
          echo "Checking if $VERSION includes the Config scroll fix..."
          
          # Fetch the config.css from upstream for this version
          CONFIG_CSS_URL="https://raw.githubusercontent.com/openclaw/openclaw/${VERSION}/ui/src/styles/config.css"
          
          CONFIG_CSS=$(curl -sf "$CONFIG_CSS_URL" 2>/dev/null || echo "")
          
          if [[ -z "$CONFIG_CSS" ]]; then
            echo "::warning::Could not fetch config.css for $VERSION, assuming fix NOT present"
            echo "has_upstream_fix=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Check for the "fixed" markers that appear in upstream main:
          # 1. .config-layout uses "height:" instead of "min-height:"
          # 2. .config-main has "min-height: 0" and "overflow: hidden"
          # 3. .config-sidebar has "min-height: 0" and "overflow: hidden"
          
          HAS_LAYOUT_HEIGHT=false
          HAS_MAIN_MINHEIGHT=false
          HAS_SIDEBAR_MINHEIGHT=false
          
          # Check for height: calc(100vh in .config-layout (not min-height)
          if echo "$CONFIG_CSS" | grep -A5 '\.config-layout' | grep -q 'height:.*calc(100'; then
            if ! echo "$CONFIG_CSS" | grep -A5 '\.config-layout' | grep -q 'min-height:.*calc(100'; then
              HAS_LAYOUT_HEIGHT=true
              echo "âœ… .config-layout uses height (not min-height)"
            fi
          fi
          
          # Check for min-height: 0 in .config-main
          if echo "$CONFIG_CSS" | grep -A10 '\.config-main' | grep -q 'min-height:.*0'; then
            HAS_MAIN_MINHEIGHT=true
            echo "âœ… .config-main has min-height: 0"
          fi
          
          # Check for min-height: 0 in .config-sidebar
          if echo "$CONFIG_CSS" | grep -A10 '\.config-sidebar' | grep -q 'min-height:.*0'; then
            HAS_SIDEBAR_MINHEIGHT=true
            echo "âœ… .config-sidebar has min-height: 0"
          fi
          
          # If all markers are present, the fix is upstream
          if [[ "$HAS_LAYOUT_HEIGHT" == "true" && "$HAS_MAIN_MINHEIGHT" == "true" && "$HAS_SIDEBAR_MINHEIGHT" == "true" ]]; then
            echo ""
            echo "ðŸŽ‰ Upstream $VERSION appears to include the scroll fix!"
            echo "   The Umbrel UI override may no longer be necessary."
            echo "   Consider building with UMBREL_UI_OVERRIDE=0 to test."
            echo ""
            echo "has_upstream_fix=true" >> $GITHUB_OUTPUT
          else
            echo ""
            echo "âš ï¸ Upstream $VERSION does NOT include all scroll fix markers"
            echo "   The Umbrel UI override is still needed."
            echo ""
            echo "has_upstream_fix=false" >> $GITHUB_OUTPUT
          fi

      - name: Determine version to build
        id: check
        env:
          INPUT_VERSION: ${{ github.event.inputs.clawdbot_version }}
          FORCE_BUILD: ${{ github.event.inputs.force_build }}
          LATEST_VERSION: ${{ steps.upstream.outputs.latest_version }}
          EVENT_NAME: ${{ github.event_name }}
        run: |
          # Use input version if provided, otherwise use latest
          VERSION="${INPUT_VERSION:-$LATEST_VERSION}"
          
          # Final validation: reject empty version
          if [[ -z "$VERSION" ]]; then
            echo "::warning::Version is empty - skipping build."
            echo "should_build=false" >> $GITHUB_OUTPUT
            echo "version=" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "Building version: ${VERSION}"
          
          # For push events (Dockerfile/patches changed), always force rebuild
          # This allows republishing the same version tag with updated overrides
          if [[ "$EVENT_NAME" == "push" ]]; then
            echo "Push event detected - forcing rebuild to apply updated overrides"
            FORCE_BUILD="true"
          fi
          
          # Check if this version's image already exists in GHCR
          # Note: GITHUB_TOKEN is used directly (not base64 encoded) for Bearer auth
          TOKEN="${{ secrets.GITHUB_TOKEN }}"
          EXISTING=$(curl -s -H "Authorization: Bearer ${TOKEN}" \
            "https://ghcr.io/v2/${{ env.IMAGE_NAME }}/tags/list" 2>/dev/null | \
            jq -r ".tags[]? | select(. == \"${VERSION}\")" || echo "")
          
          if [[ -n "$EXISTING" && "$FORCE_BUILD" != "true" ]]; then
            echo "Version ${VERSION} already exists, skipping build"
            echo "should_build=false" >> $GITHUB_OUTPUT
          else
            echo "Will build version ${VERSION}"
            echo "should_build=true" >> $GITHUB_OUTPUT
          fi
          
          echo "version=${VERSION}" >> $GITHUB_OUTPUT

  build:
    needs: check-version
    if: needs.check-version.outputs.should_build == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      digest: ${{ steps.build.outputs.digest }}
      version: ${{ needs.check-version.outputs.version }}
      publish_mode: ${{ needs.check-version.outputs.publish_mode }}
      has_upstream_fix: ${{ needs.check-version.outputs.has_upstream_fix }}
      image_tag: ${{ steps.tags.outputs.primary_tag }}
    
    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine image tags
        id: tags
        env:
          VERSION: ${{ needs.check-version.outputs.version }}
          PUBLISH_MODE: ${{ needs.check-version.outputs.publish_mode }}
        run: |
          if [[ "$PUBLISH_MODE" == "release" ]]; then
            # Release mode: version tag + latest
            echo "tags=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${VERSION},${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest" >> $GITHUB_OUTPUT
            echo "primary_tag=${VERSION}" >> $GITHUB_OUTPUT
            echo "ðŸ“¦ Release mode: tagging as ${VERSION} and latest"
          else
            # Candidate mode: candidate-version tag only (no latest)
            echo "tags=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:candidate-${VERSION}" >> $GITHUB_OUTPUT
            echo "primary_tag=candidate-${VERSION}" >> $GITHUB_OUTPUT
            echo "ðŸ§ª Candidate mode: tagging as candidate-${VERSION} (no latest)"
          fi

      - name: Build and push
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.tags.outputs.tags }}
          build-args: |
            CLAWDBOT_VERSION=${{ needs.check-version.outputs.version }}
            UMBREL_UI_OVERRIDE=${{ github.event.inputs.umbrel_ui_override == 'true' && '1' || '0' }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Validate and output digest
        run: |
          DIGEST="${{ steps.build.outputs.digest }}"
          
          # Validate digest format (must be sha256:...)
          if [[ -z "$DIGEST" ]]; then
            echo "ERROR: Digest is empty"
            exit 1
          fi
          
          if [[ ! "$DIGEST" =~ ^sha256:[a-f0-9]{64}$ ]]; then
            echo "ERROR: Invalid digest format. Expected sha256:... but got: $DIGEST"
            echo "This may indicate the docker/build-push-action returned an image ID instead of repo digest"
            exit 1
          fi
          
          echo "âœ… Image digest validated: $DIGEST"
          echo "Full image reference: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@$DIGEST"

  ui-tests:
    needs: build
    if: github.event.inputs.run_ui_tests == 'true'
    uses: ./.github/workflows/ui-regression-test.yml
    with:
      image: ghcr.io/${{ github.repository_owner }}/clawdbot-umbrel:${{ needs.build.outputs.version }}

  # Build summary (always runs after successful build)
  summary:
    needs: build
    if: needs.build.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Build Summary
        env:
          VERSION: ${{ needs.build.outputs.version }}
          DIGEST: ${{ needs.build.outputs.digest }}
          PUBLISH_MODE: ${{ needs.build.outputs.publish_mode }}
          IMAGE_TAG: ${{ needs.build.outputs.image_tag }}
          HAS_UPSTREAM_FIX: ${{ needs.build.outputs.has_upstream_fix }}
          UI_OVERRIDE: ${{ github.event.inputs.umbrel_ui_override }}
        run: |
          echo "## ðŸš€ Build Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Mode:** ${PUBLISH_MODE}" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${VERSION}" >> $GITHUB_STEP_SUMMARY
          echo "**Image Tag:** \`${IMAGE_TAG}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Digest:** \`${DIGEST}\`" >> $GITHUB_STEP_SUMMARY
          echo "**UI Override:** ${UI_OVERRIDE:-false}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Full image reference for easy copy/paste
          echo "### ðŸ“‹ Image Reference (for local testing)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "ghcr.io/${{ github.repository_owner }}/clawdbot-umbrel:${IMAGE_TAG}@${DIGEST}" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "$PUBLISH_MODE" == "candidate" ]]; then
            echo "### ðŸ§ª Candidate Build" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "This is a **candidate** build for local testing." >> $GITHUB_STEP_SUMMARY
            echo "No Umbrel App Store interaction will occur." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "To test on your Umbrel:" >> $GITHUB_STEP_SUMMARY
            echo "1. SSH into your Umbrel" >> $GITHUB_STEP_SUMMARY
            echo "2. Edit \`~/umbrel/app-data/clawdbot/docker-compose.yml\`" >> $GITHUB_STEP_SUMMARY
            echo "3. Update the \`image:\` line to the reference above" >> $GITHUB_STEP_SUMMARY
            echo "4. Run: \`umbreld client apps.restart.mutate --appId clawdbot\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "$HAS_UPSTREAM_FIX" == "true" ]]; then
            echo "### â„¹ï¸ Upstream Fix Detected" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The upstream version appears to include the Config scroll fix." >> $GITHUB_STEP_SUMMARY
            echo "The UI override is likely not needed." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

  # Umbrel App Store update (ONLY runs when explicitly requested in release mode)
  trigger-umbrel-update:
    needs: build
    # STRICT: Only trigger when ALL conditions are met:
    # 1. Build succeeded
    # 2. Release mode (not candidate)
    # 3. Explicit opt-in via update_umbrel_store=true
    # 4. Not a "main" branch build (must be a proper version)
    if: |
      needs.build.result == 'success' && 
      needs.build.outputs.publish_mode == 'release' &&
      github.event.inputs.update_umbrel_store == 'true' &&
      needs.build.outputs.version != 'main'
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Required for repository_dispatch
    steps:
      - name: Trigger Umbrel app update
        uses: peter-evans/repository-dispatch@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          event-type: new-image
          client-payload: |
            {
              "version": "${{ needs.build.outputs.version }}",
              "digest": "${{ needs.build.outputs.digest }}",
              "image": "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"
            }
      
      - name: Update Summary
        run: |
          echo "### ðŸ“¤ Umbrel App Store Update Triggered" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "The \`update-umbrel-app\` workflow has been triggered." >> $GITHUB_STEP_SUMMARY
          echo "This will update PR #4557 with the new image." >> $GITHUB_STEP_SUMMARY